#!/bin/env node

const net = require('net');
const https = require('https');
const { promisify } = require('util');
const readline = require('readline');

const DOWNLOAD_URI = 'https://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest';
const PRIORITY = 1024;

async function fetch(uri) {
    return new Promise((resolve, reject) => {
        https.get(uri, resolve);
    });
}

function ip2Int(ip) {
    const ary = ip.split('.');
    return (ary[0] << 24 | ary[1] << 16 | ary[2] << 8 | ary[3]) >>> 0;
}
function int2Ip(int) {
    return [int >>> 24, int >>> 16 & 0xff, int >>> 8 & 0xff, int & 0xff].join('.');
}
function ipRange2Cidr([start, end]) {
    const value = end - start + 1;
    const len = Math.log2(value);
    const address = int2Ip(start);
    if (Math.ceil(len) !== len) {
        console.error(`!!!!WARNING!!!!: ${address},${value} can't coverter to CIDR-style range.`);
    }
    const netmask = 32 - Math.ceil(len);
    return [address, netmask];
}

async function parse(res) {
    const rl = new readline.createInterface({
        input: res || process.stdin,
    });
    return new Promise((resolve, reject) => {
        const result = [[], []];
        const ipv4 = [];
        rl.on('line', line => {
            if (/^#/.test(line)) {
                return;
            }
            const [_registry, cc, type, start, value, _date, _status] = line.split('|');
            if (cc !== 'CN') {
                return;
            }
            if (type === 'ipv4') {
                const _ = ip2Int(start);
                ipv4.push([_, _ + Number(value) - 1]);
            } else if (type === 'ipv6') {
                result[1].push([start, value].join('/'));
            }
        });
        rl.on('error', reject);
        rl.on('close', () => {
            ipv4.sort((a, b) => Math.sign(a[0] - b[0]));
            const last = ipv4.reduce((prev, curr) => {
                if (!prev) {
                    return curr;
                }
                if (curr[0] === prev[1] + 1) {
                    console.error(`merged: ${int2Ip(prev[0])}-${int2Ip(curr[1])}`);
                    return [prev[0], curr[1]];
                } else {
                    result[0].push(prev.map(int2Ip).join('-'));
                    return curr;
                }
            }, null);
            result.push(last.map(int2Ip).join('-'));
            result.sort((a, b) => Math.sign(b[1] - a[1]));
            resolve(result);
        });
    });
}

function output(ary) {
    console.log(`
#!/usr/bin/nft -f
# Auto generated by generate-nftables-set.js on ${new Date()}
    `.trim());

    const otherAddresses = [
        /** IPv4 **/
        //'1.1.1.1', '1.0.0.1', /* Cloudflare DNS */
        //'8.8.8.8', '8.8.4.4', /* Google DNS */
        //'9.9.9.9', '149.112.112.112', /* Qua9 DNS */

        '0.0.0.0/8', /* Current network (From wiki) */
        '127.0.0.0/8', /* Loopback */
        '10.0.0.0/8', /* Private Internet Address */
        '100.64.0.0/10', /* Private Internet Address */
        '169.254.0.0/16', /* APIPA - Automatic Private IP Addressing */
        '172.16.0.0/12', /* Private Internet Address */
        '192.168.0.0/16', /* 192.168.0.0-192.168.255.255 */
        '198.18.0.0/15', /* Private network */
        '224.0.0.0/4', /* IP multicast */
        '192.0.2.0/24', '198.51.100.0/24', '203.0.113.0/24', /* Documentation */
        '192.88.99.0/24', /* 6to4 */
        '255.255.255.255/32',

        /** IPv6 **/
        '::/8', /* Loopback */
        'fc00::/7', /* Unique local addresses */
        'fe80::/10', /* Link-local addresses */
        'fec0::/10', /* Site-local addresses */
        'ff00::/8', /* Multicast addresses */
        '100::/64', /* Discard prefix */
        '2001:0000::/32', /* Teredo tunneling */
        '2001:0002::/48', /* Benchmarking, Documentation */
        '2001:0010::/28', /* ORCHID */
        '2001:0020::/28', /* ORCHIDv2 */
        '2001:db8::/32', /* Documentation */
        '2002::/16', /* 6to4 */
    ];
    console.log('');
    console.log('define FWMARK = 0x00003000');
    console.log(`\
define IPV4_ELEMENTS = {
${otherAddresses.filter(addr => addr.indexOf('.') !== -1).map(addr => addr.padStart(4 + addr.length, ' ')).join(',\n')},
${ary[0].map(addr => addr.padStart(4 + addr.length, ' ')).join(',\n')},
}
    `.trimEnd());
    console.log(`\
define IPV6_ELEMENTS = {
${otherAddresses.filter(addr => addr.indexOf(':') !== -1).map(addr => addr.padStart(4 + addr.length, ' ')).join(',\n')},
${ary[1].map(addr => addr.padStart(4 + addr.length, ' ')).join(',\n')},
}
    `.trimEnd());
}

fetch(DOWNLOAD_URI).then(parse).then(output);
